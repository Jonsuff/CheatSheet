# YOLO Object Detector 


def yolov3(input_data):
    # route_l : convolution with itself -> lbbox_pred
    # route_m : convolution with branch_m -> mbbox_pred
    # route_s : convolution with branch_s -> sbbox_pred
    route_s, route_m, route_l = darknet_53(input_data)
    ...
    return conv_sbbox, conv_mbbox, conv_lbbox


def yolo_decoder(input_data, i):
    # conv_layer결과를 실제 값으로 디코딩
    # input_data는 bbox_center & wh가 비율로 표시된 상태
    # xy : (ANCHOR + sigmoid(raw_xy)) * stride[i]
    # wh : exp(raw_wh) * ANCHOR * stride[i]
    stride = [8, 16, 32]
    conv_shape = tf.shape(input_data)
    batch_size = conv_shape[0]
    output_size = conv_shape[1]
    
    conv_output = tf.reshape(input_data, [batch_size, output_size, output_size, 3, 5 + cfg.NUM_CLASS])
    
    
    


def main():
    reader = TfrecordReader(cfg.EPOCH, cfg.BATCH_SIZE, False, cfg.TFRECORD_FILENAME)
    dataset = reader.get_dataset()
    
    input_tensor = tf.keras.layers.Input([416,416,3])
    output_tensors = []
    
    # conv_tensors = [conv_sbbox, conv_mbbox, conv_lbbox]
    conv_tensors = yolov3(input_tensor)
    
    # output_tensors : [pred_sbbox, pred_mbbox, pred_lbbox]
    for i, conv_tensor in enumerate(conv_tensors):
        pred_tensor = yolo_decoder(conv_tensor, i)
        output_tensors.append(conv_tensor)
        output_tensors.append(pred_tensor)
        
    with tf.GradientTape() as tape:
        for data in dataset:
            img_data = data["image"]
            pred_result = model(img_data)
            bbox_loss, obj_loss, prob_loss = (0,0,0)
            ....
        